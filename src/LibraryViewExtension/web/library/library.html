<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Librarie.js sample page stuff did this work</title>
    <style>
        body {
            padding: 0;
            margin: 0;
            background-color: #353535;
        }
    </style>
</head>

<body>
    <!-- Placeholders must exist before all other scripts that try to access them -->
    <div class="OuterMostContainer" id="libraryContainerPlaceholder"></div>
    
    <!-- The main library view component -->
    <script src='./dist/librarie.min.js'></script>
    
    <script>
        console.log("stuff");
        //Get hold of object registered from C#
        let csharpController = window["controller"];
        //Check if the controller is null or one of our methods does not exist.
        if (csharpController == null || csharpController.closeNodeTooltip == null) {
            throw new Error("The c# LibraryViewController was not registered into the browser correctly.")
        }

        function refreshLibraryView(libraryController) {
            //Create library container
            let jsonUrls = ["loadedTypes", "layoutSpecs"];
            let downloader = LibraryEntryPoint.CreateJsonDownloader(jsonUrls, function (jsonUrl, jsonObject) {

                let downloaded = downloader.getDownloadedJsonObjects();
                let loadedTypesJson = downloaded["loadedTypes"];
                let layoutSpecsJson = downloaded["layoutSpecs"];

                if (!loadedTypesJson || (!layoutSpecsJson)) {
                    return; // Not fully downloaded yet, bail.
                }

                // Supply loaded types and layout specs at a much later time.
                let append = false; // Replace existing contents instead of appending.
                libraryController.setLoadedTypesJson(loadedTypesJson, append);
                libraryController.setLayoutSpecsJson(layoutSpecsJson, append);
                libraryController.refreshLibraryView(); // Refresh library view.
            });
        }

        function nodeItem(name, imageFile, dynFile, folderPath, inDepth,sorting) {
            this.Name = name;
            this.imageFile = imageFile;
            this.dynFile = dynFile;
            this.folderPath = folderPath;
            this.inDepth = inDepth;
            this.sorting = sorting;
        }

        function compareStrings(a, b) {
            // Assuming you want case-insensitive comparison
            a = a.toLowerCase();
            b = b.toLowerCase();

            return (a < b) ? -1 : (a > b) ? 1 : 0;
        }

        function createActionQuery(itemType){
            switch(itemType){
                case "create":
                    return "A";
                case "action":
                    return "B";
                case "query":
                    return "C";
            }
        }


        function download(content, fileName, contentType) {
            var a = document.createElement("a");
            var file = new Blob([content], { type: contentType });
            a.href = URL.createObjectURL(file);
            console.log(a);
            a.download = fileName;
            a.click();
        }

        function dictionaryDump(libraryController) {
            var jsonDump = [];
            //entire library output
            let generatedSections = libContainer.generatedSections[0].childItems;
            var category;
            var subcategory;
            var className;
            var lowLevel;
            var path;
            var params;
            
            //iterate through different namespaces/top categories
            for (i = 0; i < generatedSections.length; i++) {
                category = generatedSections[i];
                for (j = 0; j < category.childItems.length; j++) {
                    subcategory = category.childItems[j];
                    path = category.text;
                    if (subcategory.childItems.length == 0) {
                        if (subcategory.parameters != null) {
                            params = " " + subcategory.parameters;
                        } else {
                            params = "";
                        }
                        var node = new nodeItem(subcategory.text + params, [subcategory.text + params], [subcategory.text + params], path + "/" + subcategory.itemType.charAt(0).toUpperCase() + subcategory.itemType.slice(1), "", path + createActionQuery(subcategory.itemType) + subcategory.text);
                        jsonDump.push(node);
                    } else {
                        for (k = 0; k < subcategory.childItems.length; k++) {
                            className = subcategory.childItems[k];
                            path = category.text+"/"+subcategory.text;
                            if (className.childItems.length == 0) {
                                if (className.parameters != null) {
                                    params = " " + className.parameters;
                                } else {
                                    params = "";
                                }
                                var node = new nodeItem(className.text + params, [className.text + params], [className.text + params], path + "/" + className.itemType.charAt(0).toUpperCase() + className.itemType.slice(1), "", (path + createActionQuery(className.itemType) + className.text).replace(/ /g, ''));
                                jsonDump.push(node);
                            } else {
                                for (l = 0; l < className.childItems.length; l++) {
                                    lowLevel = className.childItems[l];
                                    path = category.text + "/" + subcategory.text + "/" + className.text;
                                    if (lowLevel.childItems.length == 0) {
                                        if (lowLevel.parameters != null) {
                                            params = " " + lowLevel.parameters;
                                        } else {
                                            params = "";
                                        }
                                        var node = new nodeItem(lowLevel.text + params, [lowLevel.text + params], [lowLevel.text + params ], path + "/" + lowLevel.itemType.charAt(0).toUpperCase() + lowLevel.itemType.slice(1), "", (path + createActionQuery(lowLevel.itemType) + lowLevel.text).replace(/ /g, ''));
                                        jsonDump.push(node);
                                    }
                                }
                            }
                        }
                    }
                }
                jsonDump.sort(function(a, b) {
                    return compareStrings(a.sorting, b.sorting);
                })
            }
            jsonDump.forEach(function (v) { delete v.sorting });
            //console.log(jsonDump);
            //download(JSON.stringify(jsonDump), 'C:/Users/williar/AppData/Local/Temp/json.txt', 'text/plain');
            var result = loadJSON(function (json) {
                var jsonFinal = jsonMerge(jsonDump, json);
                console.log(jsonFinal);
                download(JSON.stringify(jsonDump), 'C:/Users/williar/AppData/Local/Temp/json.txt', 'text/plain');
            });
            
            
        }

        function jsonMerge(jsonNew,jsonOrig) {
            //console.log(jsonOrig);
            for (i in jsonOrig) {
                for (k in jsonNew) {
                    var newCat = jsonNew[k].folderPath.split('/')[0];
                    if (jsonNew[k].Name == jsonOrig[i].Name) {
                        switch (newCat) {
                            case "Dictionary":
                                jsonNew[k].inDepth = "";
                                break;
                            case "Geometry":
                                if (jsonNew[k].folderPath.split('/')[2] == jsonOrig[i].folderPath.split('/')[1]) {
                                    jsonNew[k].inDepth = jsonOrig[i].inDepth;
                                } else {
                                    jsonNew[k].inDepth = jsonOrig[i].inDepth;
                                }
                                break;
                            default:
                                jsonNew[k].inDepth = jsonOrig[i].inDepth;
                                break;
                        }
                    } 
                }
            }
            return jsonNew;
        }

        function loadJSON(callback) {
            var xobj = new XMLHttpRequest();
            xobj.overrideMimeType("application/json");
            xobj.open('GET', './dist/Dynamo_Nodes_Documentation.json', true);
            xobj.onreadystatechange = function () {
                if (xobj.readyState == 4 && xobj.status == "200") {
                    callback(JSON.parse(xobj.responseText));
                }
            };
            xobj.send(null);
        }

        //Create library controller
        let libController = LibraryEntryPoint.CreateLibraryController();

        //Create library view
        let libContainer = libController.createLibraryByElementId("libraryContainerPlaceholder");
        
        //Update the view with contents
        refreshLibraryView(libController);

        //return all nodes as JSON
        //for (i=0; i < libContainer.)

        libController.searchLibraryItemsHandler = function (text, callback) {
			let encodedText = encodeURIComponent(text);
            let url = "nodeSearch" + "/" + encodedText;
            let jsonUrls = [url];
            let downloader = LibraryEntryPoint.CreateJsonDownloader(jsonUrls, function (jsonUrl, jsonObject) {

                let downloaded = downloader.getDownloadedJsonObjects();
                let searchLoadedTypesJson = downloaded[url];

                if (!searchLoadedTypesJson) {
                    //console.log("Error: no search result.");
                    return;
                }
                csharpController.logEventsToInstrumentation("Search", encodedText);
                callback(searchLoadedTypesJson);
            });
        }

        // Register event handlers for various events on library controller and package controller.

        libController.on(libController.ItemClickedEventName, function (nodeCreationName) {
            //console.log('Library Node Clicked: ' + nodeCreationName);
            //csharpController.closeDetailsView(); //ensure that the details view is closed.
            csharpController.createNode(nodeCreationName);
            dictionaryDump(libController);
            
        });

        libController.on(libController.ItemMouseEnterEventName, function (arg) {
            //console.log('Mouse entered: ' + arg.data);
            csharpController.showNodeTooltip(arg.data, arg.rect.top);
        });

        libController.on(libController.ItemMouseLeaveEventName, function (arg) {
            //console.log('Mouse left: ' + arg.data);
            csharpController.closeNodeTooltip(true);
        });

        libController.on(libController.SectionIconClickedEventName, function (section) {
            //console.log("Section clicked: " + section);
            if (section == "Add-ons") {
                csharpController.importLibrary();
            }
        });

        libController.on(libController.FilterCategoryEventName, function (item) {
            var categories = [];
            item.forEach((elem) => {
                var catString = elem.name + ":" + (elem.checked ? "Selected" : "Unselected");
                categories.push(catString); 
            });

            csharpController.logEventsToInstrumentation("Filter-Categories", categories.join(","));
        });

        csharpController.on("error", function (msg) {
            //console.log("Error: " + msg);
            pkgController.raiseEvent("error", msg);
        });

        csharpController.on("libraryDataUpdated", function (items) {
            //console.log(items);
            refreshLibraryView(libController);
            csharpController.closeNodeTooltip(true);

        });

    </script>

</body>

</html>
